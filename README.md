# mssim

[난 c++로 서울 2033 같은 텍스트 어드벤처 게임을 만들려고한다. 
화면 상단에 체력 멘탈 재력이 표시되며 남은 잔량은 숫자로 표시된다 (최대3 최하 0) 멘탈은 선택지로 체력은 전투 혹은 선택지로 줄어들며 0이되면 사망한다

이야기의 텍스트는 화면 중간에 그리고 하단부에는 선택지가 보인다  

플레이어는 체력, 멘탈, 아이템인벤토리, 능력인벤토리, 공격력 능력치, 돈을 가짐

룸은 이벤트, NPC,적, 트랩을 가짐

적과는 전투,대화 npc하고는 대화,이벤트(거래) 트랩은 트랩에걸려서피달기,피하는 이벤트를 가짐

능력이나 아이템을 게임진행시 (이벤트의 결과에 따라) 얻을 수 있는데 이것들은 선택지에서 추가적으로 사용이 가능하다 만약 Excalibur 라는 이벤트가 등장해 1. 힘으로 뽑아본다. (랜덤 확률로 성공, 실패시 체력 1 하락) 2. 그냥 지나간다 인데 만약 내가 근력 능력이 있다면 1. 힘으로 뽑아본다 (근력) 으로 표시가되며 반드시 성공 하는식 


다음은 이 시스템의 주요 기능을 설명하는 4가지 큰 맥락입니다.

1. 플레이어와 환경의 상호작용: GameManager와 EventManager의 협력
GameManager는 게임의 핵심 컨트롤러 역할을 합니다.
게임을 초기화하고, 각 상호작용을 조정하고, 게임의 전체 흐름을 관리하죠.
예를 들어, 플레이어가 NPC와 상호작용할 때 GameManager는 EventManager를 통해 해당 상호작용 이벤트를 생성합니다.
이벤트는 스토리를 진행하고, 선택지를 제공하며, 다양한 상호작용을 촉진합니다.
이 구조 덕분에 플레이어는 모든 상호작용을 자연스럽게 연결된 이야기처럼 느낄 수 있습니다.
2. 몬스터와의 전투: CombatManager와 BaseMonster의 역할 분담
게임의 핵심은 전투 시스템이며, 이를 위해 CombatManager가 있습니다.
CombatManager는 전투의 시작과 진행, 종료를 모두 관리합니다.
전투에 돌입하면 플레이어는 턴마다 선택을 하고, 몬스터는 이에 반응하며 공격합니다.
각각의 몬스터 객체(Goblin, Dragon)는 BaseMonster 클래스를 상속받아 고유의 공격력과 방어력을 가집니다.
CombatManager는 각 몬스터의 상태를 직접 가져와 전투 흐름을 자연스럽게 이어갑니다.
3. 다양한 상호작용: InteractionManager와 IInteractable 인터페이스를 통한 확장성
플레이어는 단순한 전투 외에도 다양한 상호작용을 할 수 있습니다.
InteractionManager는 IInteractable 인터페이스를 통해 여러 객체와 상호작용할 수 있도록 지원합니다.
각 객체는 상호작용 시 고유한 행동을 수행할 수 있습니다. 예를 들어, Goblin은 공격을 시작하고, Shopkeeper는 상점을 열어 아이템을 거래할 수 있습니다.
이 인터페이스 덕분에 새로운 상호작용 객체를 추가할 때도 일관성을 유지할 수 있으며, 확장성이 뛰어난 시스템을 구성할 수 있습니다.
4. 이벤트 선택지와 결과: Event와 ActionResult의 유기적 연결
Event 클래스는 상호작용 이벤트의 주요 내용을 담고 있습니다.
이벤트는 플레이어에게 선택지를 제시하고, 각 선택은 ActionResult를 통해 다양한 결과를 유도합니다.
예를 들어, 플레이어가 Event를 통해 Goblin과 전투를 시작하도록 선택하면, ActionResult는 해당 CombatManager와 Goblin 객체를 호출하여 전투를 진행합니다.
이를 통해 각 선택은 결과와 연결되어 있어, 플레이어의 행동에 따른 게임 변화가 극적으로 전달됩니다.
마무리: 상호작용의 체계적 연결과 확장성 있는 설계
이 시스템은 상호작용을 통해 몰입도 높은 콘솔 RPG 경험을 제공합니다.
GameManager를 중심으로 CombatManager, EventManager, InteractionManager 등이 긴밀하게 연결되어 있어, 확장성과 유지보수성에서 뛰어난 구조를 보여줍니다.
객체별로 고유한 상호작용 방식과 선택지 기반의 결과 시스템을 통해, 플레이어는 게임 내 다양한 상황에 대응하며 몰입감을 느낄 수 있습니다.

. 플레이어와 환경의 상호작용: GameManager와 EventManager의 협력
사용된 디자인 패턴: 싱글톤(Singleton) 패턴

설명: GameManager는 싱글톤 패턴으로 설계되어, 게임에서 단일 인스턴스로 게임 상태와 흐름을 관리합니다.

게임을 초기화하고, 각 상호작용을 조정하며, 전체 게임의 흐름을 단일 객체로 관리하죠.

예를 들어, 플레이어가 NPC와 상호작용할 때 GameManager는 EventManager를 통해 이벤트를 생성하고, 스토리를 진행하며 상호작용을 조율합니다.

효과: 싱글톤 패턴 덕분에 GameManager와 EventManager는 전역 상태를 관리하여 여러 객체의 일관된 게임 경험을 유지할 수 있습니다.

2. 몬스터와의 전투: CombatManager와 BaseMonster의 역할 분담
사용된 디자인 패턴: 상태(State) 패턴

설명: CombatManager는 전투의 모든 단계(전투 시작, 플레이어 턴, 몬스터 턴, 전투 종료)를 관리합니다.

이 과정에서 상태 패턴을 통해 전투 상태를 PlayerTurn, EnemyTurn, EndCombat 등으로 전환하여 전투 진행을 제어합니다.

각각의 몬스터 객체(Goblin, Dragon)는 BaseMonster 클래스를 상속받아 고유한 전투 행동을 수행하며, CombatManager가 각 몬스터의 상태를 직접 참조하여 전투 진행 상황을 관리합니다.

효과: 상태 패턴을 통해 전투의 흐름이 명확해지고, 각 상태가 독립적 로직을 가지면서도 유기적으로 연결됩니다.

3. 다양한 상호작용: InteractionManager와 IInteractable 인터페이스를 통한 확장성
사용된 디자인 패턴: 인터페이스(Interface) 패턴, 팩토리(Factory) 패턴

설명: IInteractable 인터페이스는 상호작용 가능한 모든 객체가 구현해야 하는 표준을 정의합니다.

InteractionManager는 이를 사용하여 모든 객체가 일관된 방식으로 상호작용할 수 있도록 관리하며, 팩토리 패턴을 통해 다양한 상호작용 객체(몬스터, NPC, 트랩 등)를 동적으로 생성할 수 있습니다.

예를 들어, Goblin은 전투를, Shopkeeper는 아이템 거래를 수행하며, 각 객체가 개별적으로 고유의 상호작용을 구현할 수 있습니다.

효과: 인터페이스와 팩토리 패턴의 조합 덕분에 새로운 상호작용 객체를 쉽게 추가할 수 있어 확장성이 뛰어납니다.

4. 이벤트 선택지와 결과: Event와 ActionResult의 유기적 연결
사용된 디자인 패턴: 명령(Command) 패턴, 전략(Strategy) 패턴

설명: Event 클래스는 선택지를 통해 이벤트를 관리하고, 플레이어의 선택에 따라 ActionResult가 다양한 결과를 발생시킵니다.

Command 패턴은 플레이어의 선택이 수행할 동작을 추상화하고, Strategy 패턴은 선택지에 따른 특정 액션(전투 시작, 아이템 사용 등)을 개별 전략으로 구분하여 실행합니다.

예를 들어, 플레이어가 고블린과의 전투를 선택하면, Event는 CombatManager와 Goblin 객체를 호출해 전투를 실행합니다.

효과: 명령 및 전략 패턴을 통해 각 선택이 독립적이면서도 결과에 따라 다양한 액션을 수행할 수 있습니다. 